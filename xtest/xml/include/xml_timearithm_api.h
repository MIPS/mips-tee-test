/*
 * Copyright (c) 2017-2018, MIPS Tech, LLC and/or its affiliated group companies
 * (“MIPS”).
 * Copyright (c) 2014, STMicroelectronics International N.V.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License Version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 */

#ifndef XML_TIMEARITHM_API_H_
#define XML_TIMEARITHM_API_H_

#include <openssl/bn.h>

#include "xml_common_api.h"
#include "xtest_ta_defines.h"

#ifdef USER_SPACE
#include <pthread.h>
#endif

/* This structure is the same as defined in TTA_Arithmetical_protocol.h */
#define TTA_VALUES_FIRST_BIG_INT_FMM	310
#define TTA_VALUES_NUMBER_OF_BIGINTS	15

static uint32_t FIELD_NOT_USED = 0;

typedef struct {
	uint32_t 	*aBigInts[TTA_VALUES_NUMBER_OF_BIGINTS];

	int32_t		nShortVal;
	bool 		bShortValSet;

	uint32_t 	*pBigIntFMMContext;

	uint32_t 	*aBigIntFMMs[TTA_VALUES_NUMBER_OF_BIGINTS];
} TTA_Internal_Data;

static TTA_Internal_Data __ca_data;
TTA_Internal_Data *p_ca_data = &__ca_data;

static uint32_t **getBigIntPtrFromId(TTA_Internal_Data *pInternalData, uint32_t id)
{
	uint32_t **ppBigInt;

	if (id < TTA_VALUES_NUMBER_OF_BIGINTS)
	{
		ppBigInt = &(pInternalData->aBigInts[id]);
	}
	else
	{
		ppBigInt = NULL;
	}

	return ppBigInt;
}

static uint32_t *getBigIntFromId(TTA_Internal_Data *pInternalData, uint32_t id)
{
	uint32_t **ppBigInt = getBigIntPtrFromId(pInternalData, id);

	if (ppBigInt == NULL)
		return NULL;
	else
		return *ppBigInt;
}

static uint32_t **getBigIntFMMPtrFromId(TTA_Internal_Data *pInternalData, uint32_t id)
{
	uint32_t **ppBigInt;

	if (id < TTA_VALUES_FIRST_BIG_INT_FMM)
		return NULL;

	id -= TTA_VALUES_FIRST_BIG_INT_FMM;

	if (id < TTA_VALUES_NUMBER_OF_BIGINTS)
		ppBigInt = &(pInternalData->aBigIntFMMs[id]);
	else
		ppBigInt = NULL;

	return ppBigInt;
}

#define Invoke_GetSystemTime Invoke_Simple_Function
#define Invoke_GetREETime Invoke_Simple_Function
#define Invoke_SetTAPersistentTime_and_GetTAPersistentTime_Overflow \
	Invoke_Simple_Function
#define Invoke_SetTAPersistentTime_and_GetTAPersistentTime \
	Invoke_Simple_Function
#define Invoke_GetTAPersistentTime_NotSet_and_SetTAPersistentTime \
	Invoke_Simple_Function
#define Test_Tool_Erase_Persistent_Time Invoke_Simple_Function

#define Invoke_BigIntCmpS32 Invoke_BigIntCmp
#define Invoke_BigIntIsProbablePrime Invoke_BigIntCmp
#define Invoke_BigIntRelativePrime Invoke_BigIntCmp
#define Invoke_BigIntConvertToFMM Invoke_BigIntConvertFromFMM
#define Invoke_BigIntConvertToS32(c, sess, cmd, short_val, dest) \
	Invoke_BigIntConvertFromS32(c, sess, cmd, dest, short_val)

static TEEC_SharedMemory *SHARE_MEM01;
static TEEC_SharedMemory *SHARE_MEM02;
static TEEC_SharedMemory *SHARE_MEM03;
static TEEC_Session *SESSION01;
static TEEC_Context *CONTEXT01;
static TEEC_Context *CONTEXT02;
static TEEC_Operation *OPERATION01;

#define CMD_TEE_SetTAPersistentTime_and_GetTAPersistentTime_Overflow \
	CMD_TEE_SetTAPersistentTime_and_GetTAPersistentTimeOverflow

#ifdef USER_SPACE
/*Test data defines*/
//static pthread_t THREAD01_DEFAULT;
static pthread_t THREAD02;
#endif

#if WITH_ARITHMETIC_API
#define BIT0_MASK 1
#define BIT1_MASK 2
#define BIT2_MASK 4

#define NEGATIVE 0
#define POSITIVE 1

#define RESULT_NOT_A_PRIME 0
#define RESULT_PRIME 1

#define RESULT_EQUAL 0
#define RESULT_INTEGER_GREATER_THAN_ZERO 1
#define RESULT_INTEGER_LOWER_THAN_ZERO 2
#endif

#define CASE_WAIT_CANCELLED 1
#define CASE_WAIT_SUCCESS 2

#define MAX_INT32_POSITIVE_VALUE 2147483647

/* All stored values roles */
#define BIG_INT_1 	 0u
#define BIG_INT_2 	 1u
#define BIG_INT_3 	 8
#define BIG_INT_4 	 9
#define FMM_BIG_INT_1 	 310
#define FMM_BIG_INT_2 	 311
#define FMM_CONTEXT_1 	 300
#define FMM_RESULT 	 312
#define MODULUS 	 2
#define REE_NULL 	 200
#define RESULT 	 3
#define RESULT_4 	 6
#define RESULT_5 	 7
#define RESULT_FMM_CONVERTED 	 10
#define RESULT_U 	 4
#define RESULT_V 	 5
#define SHORT_VAL_1 	 100
/* All BigInt probability results */
#define RESULT_NOT_A_PRIME_SURE 	 0
#define RESULT_PRIME_SURE_OR_MAYBE 	 1

#if WITH_ARITHMETIC_API
/* All BigInt confidence levels */
static uint32_t CONFIDENCE_LEVEL_80 = 80;

static uint8_t BIG_VALUE1_SIZE_64_BITS[] = {
	0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
};


static uint8_t BIG_VALUE2_SIZE_64_BITS[] = {
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static uint8_t BIG_VALUE3_SIZE_32_BITS[] = {
	0x0F, 0xFF, 0xFF, 0xFF,
};

static uint8_t BIG_VALUE4_SIZE_32_BITS[] = {
	0x01, 0x00, 0x00, 0x00,
};

static uint8_t BIG_VALUE5_SIZE_2048_BITS[] = {
	0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
};

static uint8_t BIG_VALUE6_SIZE_2048_BITS[] = {
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
};

static uint8_t BIG_VALUE7_SIZE_1024_BITS[] = {
	0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
};

static uint8_t BIG_VALUE9_SIZE_64_BITS_PRIME_WITH_VALUE1[] = {
	0x0E, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

static uint8_t BIG_VALUE10_SIZE_32_BITS_PRIME_WITH_VALUE3[] = {
	0x0E, 0xFF, 0xFF, 0xFF,
};

static uint8_t  BIG_VALUE11_SIZE_2048_BITS_PRIME_WITH_VALUE5[] = {
	0x0E, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
};

static uint8_t BIG_VALUE13_SIZE_32_BITS_PRIME[] = {
	0x00, 0x00, 0x0D, 0x69,
};

static uint8_t BIG_VALUE14_SIZE_32_BITS_NOT_PRIME[] = {
	0x00, 0x00, 0x0D, 0x68,
};

static uint8_t BIG_VALUE15_SIZE_32_BITS[] = {
	0x00, 0x00, 0x00, 0x03,
};

static uint8_t BIG_VALUE16_SIZE_64_BITS[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
};

static uint8_t BIG_VALUE17_SIZE_1024_BITS[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x03,
};

static uint8_t BIG_VALUE18_SIZE_2048_BITS[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x03,
};

 static uint8_t BIG_VALUE19_SIZE_32_BITS_PRIME_WITH_VALUE15[] ={
 	0x00, 0x00, 0x00, 0x04
 };

static uint8_t BIG_VALUE20_SIZE_2048_BITS_PRIME_WITH_VALUE18[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x04,
};

static uint8_t BIG_VALUE21_SIZE_64_BITS[] = {
	0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF
};
static uint8_t BIG_VALUE22_SIZE_32_BITS_LIMIT_INT32[] = {0x80, 0x00, 0x00, 0x00};
static uint8_t BIG_VALUE23_SIZE_32_BITS[] = {0x01, 0x00, 0x00, 0x01};
static uint8_t BIG_VALUE24_SIZE_64_BITS[] = {0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};

static uint8_t BIG_VALUE25_SIZE_2048_BITS[] = {
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
};

static uint8_t BIG_VALUE_ONE_SIZE_64_BITS[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
};

static uint8_t BIG_VALUE_TWO_SIZE_1024_BITS[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02
};

static uint8_t BIG_VALUE_TWO_SIZE_2048_BITS[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02
};

static uint8_t BIG_VALUE_TWO_SIZE_32_BITS[] ={
	0x00, 0x00, 0x00, 0x02
};
static uint8_t BIG_VALUE_TWO_SIZE_64_BITS[] ={
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02
};
static uint8_t BIG_VALUE_ZERO_SIZE_32_BITS[] = {
	0x00, 0x00, 0x00, 0x00,
};
static uint8_t BIG_VALUE_ZERO_SIZE_64_BITS[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
static uint8_t BIG_VALUE_ZERO_SIZE_2048_BITS[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
};

/** ALL_TEEC_UUID
 *
 * These constants are the UUID of existing
 * Trusted Applications
 */
/* "SMARTCLSARITHMET" */
static TEEC_UUID UUID_TTA_testingInternalAPI_Arithmetique = {
	0x534D4152, 0x5443, 0x4C53,
	{ 0x41, 0x52, 0x49, 0x54, 0x48, 0x4D, 0x45, 0x54 }
};
#endif

/* "SMARTCSL_TIMEAPI" */
static TEEC_UUID UUID_TTA_testingInternalAPI_Time = {
	0x534D4152, 0x5443, 0x534C,
	{ 0x5F, 0x54, 0x49, 0x4D, 0x45, 0x41, 0x50, 0x49 }
};

/*Helper functions/macros*/

#if WITH_ARITHMETIC_API
#define BN_DECLARE_AND_INIT(exit_label) \
	BN_CTX *ctx = NULL; \
	ctx = BN_CTX_new(); \
	if (ctx == NULL) { \
		goto exit_label; \
	} \

#define BN_FREE() \
	if (ctx) { \
		BN_CTX_free(ctx); \
	}
#endif

#define TEEC_createThread(a, b) /*do nothing for now*/

#ifdef USER_SPACE
static void *cancellation_thread(void *arg)
{
	TEEC_RequestCancellation((TEEC_Operation *)arg);
	return NULL;
}
#endif

#ifdef USER_SPACE
#define RequestCancellation(op) \
	(void)ADBG_EXPECT(c, 0, \
			  pthread_create(&THREAD02, NULL, cancellation_thread, \
					 (void *)op)); \
	(void)ADBG_EXPECT(c, 0, pthread_join(THREAD02, NULL));
#else
#define RequestCancellation(op) \
	IDENTIFIER_NOT_USED(op)
#endif

static TEEC_Result Invoke_NewBigInt(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t role, uint32_t size_N);
static TEEC_Result Invoke_BigIntConvertFromOctetString(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t role, uint32_t size_N, uint32_t sign, uint8_t *value);

#define Macro_StoreBigInt(c, sess, roles, size, sign, value) \
	({ \
		TEEC_Result __ret = Invoke_NewBigInt(c, sess, CMD_Arithm_TTA_New_BigInt, \
				roles, size); \
		if (!__ret) \
			__ret =  Invoke_BigIntConvertFromOctetString(c, sess, \
				CMD_Arithm_BigIntConvertFromOctetString, roles, size, sign, value); \
		__ret; \
	})

static TEEC_Result Invoke_Simple_Function(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId)
{
	TEEC_Result res = TEE_ERROR_NOT_SUPPORTED;
	TEEC_Operation op = TEEC_OPERATION_INITIALIZER;
	uint32_t org;
	(void)c;

	op.paramTypes = TEEC_PARAM_TYPES(
		TEEC_NONE, TEEC_NONE, TEEC_NONE, TEEC_NONE);

	res = TEEC_InvokeCommand(sess, cmdId, &op, &org);

	return res;
}

static TEEC_Result __invoke_command_2_value_input(TEEC_Session *sess,
	uint32_t cmdId, uint32_t *param0_a, uint32_t *param0_b,
	uint32_t *param1_a, uint32_t *param1_b, uint32_t *org)
{
	TEEC_Operation op = TEEC_OPERATION_INITIALIZER;

	op.params[0].value.a = *param0_a;
	op.params[0].value.b = *param0_b;
	op.params[1].value.a = *param1_a;
	op.params[1].value.b = *param1_b;

	op.paramTypes = TEEC_PARAM_TYPES(
		TEEC_VALUE_INPUT, TEEC_VALUE_INPUT, TEEC_NONE, TEEC_NONE);

	return TEEC_InvokeCommand(sess, cmdId, &op, org);
}

static TEEC_Result Invoke_BigIntAdd(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t dest, uint32_t op1, uint32_t op2)
{
	TEEC_Result res = TEE_ERROR_NOT_SUPPORTED;
	uint32_t org;
	BIGNUM *pBigIntOP1;
	BIGNUM *pBigIntOP2;
	BIGNUM *pBigIntDest;

	(void)c;

	res = __invoke_command_2_value_input(sess, cmdId, &dest, &FIELD_NOT_USED, &op1, &op2, &org);

	if (res != TEE_SUCCESS)
		goto bn_add_end;
	pBigIntOP1 = (BIGNUM *)getBigIntFromId(p_ca_data, op1);
	if (pBigIntOP1 == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_add_err;
	}
	pBigIntOP2 = (BIGNUM *)getBigIntFromId(p_ca_data, op2);
	if (pBigIntOP2 == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_add_err;
	}
	pBigIntDest = (BIGNUM *)getBigIntFromId(p_ca_data, dest);
	if (pBigIntDest == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_add_err;
	}

	if (BN_add(pBigIntDest, pBigIntOP1, pBigIntOP2))
		goto bn_add_end;

bn_add_err:
	BN_clear_free(pBigIntDest);
bn_add_end:
	return res;
}

static TEEC_Result Invoke_BigIntAddMod(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t dest, uint32_t op1, uint32_t op2, uint32_t mod)
{
	TEEC_Result res = TEE_ERROR_NOT_SUPPORTED;
	uint32_t org;
	BIGNUM *pBigIntOP1;
	BIGNUM *pBigIntOP2;
	BIGNUM *pBigIntMod;
	BIGNUM *pBigIntDest;
	(void)c;

	BN_DECLARE_AND_INIT(bn_mod_add_end);
	res = __invoke_command_2_value_input(sess, cmdId, &dest, &mod, &op1, &op2, &org);

	if (res != TEE_SUCCESS)
		goto bn_mod_add_end;
	pBigIntDest = (BIGNUM *)getBigIntFromId(p_ca_data, dest);
	if (pBigIntDest == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_mod_add_end;
	}
	pBigIntOP1 = (BIGNUM *)getBigIntFromId(p_ca_data, op1);
	if (pBigIntOP1 == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_mod_add_err;
	}
	pBigIntOP2 = (BIGNUM *)getBigIntFromId(p_ca_data, op2);
	if (pBigIntOP2 == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_mod_add_err;
	}
	pBigIntMod = (BIGNUM *)getBigIntFromId(p_ca_data, mod);
	if (pBigIntMod == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_mod_add_err;
	}

	if (BN_mod_add(pBigIntDest, pBigIntOP1, pBigIntOP2, pBigIntMod, ctx))
		goto bn_mod_add_end;

bn_mod_add_err:
	BN_clear_free(pBigIntDest);
bn_mod_add_end:
	BN_FREE();
	return res;
}

static TEEC_Result Invoke_BigIntCmp(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t op1, uint32_t op2, uint32_t expected)
{
	TEEC_Result res = TEE_ERROR_NOT_SUPPORTED;
	uint32_t org;
	(void)c;

	res = __invoke_command_2_value_input(sess, cmdId, &expected, &FIELD_NOT_USED, &op1, &op2,
		&org);

	return res;
}

static TEEC_Result __invoke_command_3_value_input(TEEC_Session *sess,
	uint32_t cmdId, uint32_t *param0_a, uint32_t *param0_b,
	uint32_t *param1_a, uint32_t *param1_b, uint32_t *param2_a,
	uint32_t *param2_b, uint32_t *org)
{
	TEEC_Operation op = TEEC_OPERATION_INITIALIZER;

	op.params[0].value.a = *param0_a;
	op.params[0].value.b = *param0_b;
	op.params[1].value.a = *param1_a;
	op.params[1].value.b = *param1_b;
	op.params[2].value.a = *param2_a;
	op.params[2].value.b = *param2_b;

	op.paramTypes = TEEC_PARAM_TYPES(
		TEEC_VALUE_INPUT, TEEC_VALUE_INPUT, TEEC_VALUE_INPUT, TEEC_NONE);

	return TEEC_InvokeCommand(sess, cmdId, &op, org);
}

static TEEC_Result Invoke_BigIntComputeExtendedGcd(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t gcd, uint32_t dest_u, uint32_t dest_v,
	uint32_t op1, uint32_t op2)
{
	TEEC_Result res = TEE_ERROR_NOT_SUPPORTED;
	uint32_t org;
	BIGNUM *pBigIntOP1;
	BIGNUM *pBigIntOP2;
	BIGNUM *pBigIntGcd;
	(void)c;

	BN_DECLARE_AND_INIT(bn_gcd_end);
	res = __invoke_command_3_value_input(sess, cmdId, &gcd, &FIELD_NOT_USED, &dest_u,
		&dest_v, &op1, &op2, &org);

	if (res != TEE_SUCCESS)
		goto bn_gcd_end;

	pBigIntGcd = (BIGNUM *)getBigIntFromId(p_ca_data, gcd);
	if (pBigIntGcd == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_gcd_end;
	}

	pBigIntOP1 = (BIGNUM *)getBigIntFromId(p_ca_data, op1);
	if (pBigIntOP1 == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_gcd_err;
	}
	pBigIntOP2 = (BIGNUM *)getBigIntFromId(p_ca_data, op2);
	if (pBigIntOP2 == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_gcd_err;
	}

	if (BN_gcd(pBigIntGcd, pBigIntOP1, pBigIntOP2, ctx))
		goto bn_gcd_end;

bn_gcd_err:
	BN_clear_free(pBigIntGcd);
bn_gcd_end:
	BN_FREE();
	return res;
}

static TEEC_Result Invoke_BigIntComputeFMM(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t dest, uint32_t op1, uint32_t op2, uint32_t mod, uint32_t context)
{
	uint32_t org;
	(void)c;

	return __invoke_command_3_value_input(sess, cmdId, &context, &mod, &dest,
		&FIELD_NOT_USED, &op1, &op2, &org);
}

static TEEC_Result __invoke_command_1_value_input(TEEC_Session *sess,
	uint32_t cmdId, uint32_t *param0_a, uint32_t *param0_b, uint32_t *org)
{
	TEEC_Operation op = TEEC_OPERATION_INITIALIZER;

	op.params[0].value.a = *param0_a;
	op.params[0].value.b = *param0_b;

	op.paramTypes = TEEC_PARAM_TYPES(
		TEEC_VALUE_INPUT, TEEC_NONE, TEEC_NONE, TEEC_NONE);

	return TEEC_InvokeCommand(sess, cmdId, &op, org);
}

static TEEC_Result Invoke_BigIntConvertFromS32(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t dest, uint32_t short_val)
{
	uint32_t org;
	(void)c;

	return __invoke_command_1_value_input(sess, cmdId, &dest, &short_val, &org);
}

static TEEC_Result Invoke_BigIntConvertFromFMM(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t dest, uint32_t src, uint32_t mod, uint32_t context)
{
	uint32_t org;
	(void)c;

	return __invoke_command_3_value_input(sess, cmdId, &context, &mod, &dest,
		&FIELD_NOT_USED, &src, &FIELD_NOT_USED, &org);
}

static TEEC_Result Invoke_BigIntDiv(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t dest_q, uint32_t dest_r, uint32_t op1, uint32_t op2)
{
	TEEC_Result res = TEE_ERROR_NOT_SUPPORTED;
	uint32_t org;
	BIGNUM *pBigIntDestQ = NULL;
	BIGNUM *pBigIntDestR = NULL;
	BIGNUM *pBigIntOP1;
	BIGNUM *pBigIntOP2;
	(void)c;

	BN_DECLARE_AND_INIT(bn_div_end);
	res = __invoke_command_2_value_input(sess, cmdId, &dest_q, &dest_r, &op1, &op2, &org);

	if (res == TEE_SUCCESS) {
		pBigIntOP1 = (BIGNUM *)getBigIntFromId(p_ca_data, op1);
		if (pBigIntOP1 == NULL) {
			res = TEE_ERROR_NOT_SUPPORTED;
			goto bn_div_err;
		}

		pBigIntOP2 = (BIGNUM *)getBigIntFromId(p_ca_data, op2);
		if (pBigIntOP2 == NULL) {
			res = TEE_ERROR_NOT_SUPPORTED;
			goto bn_div_err;
		}

		if (dest_q != REE_NULL) {
			pBigIntDestQ = (BIGNUM *)getBigIntFromId(p_ca_data, dest_q);
			if (pBigIntDestQ == NULL) {
				res = TEE_ERROR_NOT_SUPPORTED;
				goto bn_div_err;
			}
		}
		if (dest_r != REE_NULL) {
			pBigIntDestR = (BIGNUM *)getBigIntFromId(p_ca_data, dest_r);
			if (pBigIntDestR == NULL) {
				res = TEE_ERROR_NOT_SUPPORTED;
				goto bn_div_err;
			}
		}
		if (BN_div(pBigIntDestQ, pBigIntDestR, pBigIntOP1, pBigIntOP2, ctx))
			goto bn_div_end;

	}

bn_div_err:
	BN_clear_free(pBigIntDestQ);
	BN_clear_free(pBigIntDestR);
bn_div_end:
	BN_FREE();
	return res;
}

static TEEC_Result Invoke_BigIntGetBit(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t src, int32_t BitIndex, bool expectedBooleanResult)
{
	TEEC_Result res = TEE_ERROR_NOT_SUPPORTED;
	TEEC_Operation op = TEEC_OPERATION_INITIALIZER;
	uint32_t org;

	op.params[0].value.a = src;
	op.params[0].value.b = BitIndex;

	op.paramTypes = TEEC_PARAM_TYPES(
		TEEC_VALUE_INPUT, TEEC_VALUE_OUTPUT, TEEC_NONE, TEEC_NONE);

	res = TEEC_InvokeCommand(sess, cmdId, &op, &org);

	(void)ADBG_EXPECT_COMPARE_SIGNED(c, op.params[1].value.a, ==,
					 expectedBooleanResult);

	return res;
}

static TEEC_Result Invoke_BigIntGetBitCount(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t src, uint32_t ExpectedBitCount)
{
	TEEC_Result res = TEE_ERROR_NOT_SUPPORTED;
	TEEC_Operation op = TEEC_OPERATION_INITIALIZER;
	uint32_t org;

	op.params[0].value.a = src;
	op.paramTypes = TEEC_PARAM_TYPES(
		TEEC_VALUE_INPUT, TEEC_VALUE_OUTPUT, TEEC_NONE, TEEC_NONE);

	res = TEEC_InvokeCommand(sess, cmdId, &op, &org);

	(void)ADBG_EXPECT_COMPARE_SIGNED(c, op.params[1].value.a, ==,
					 ExpectedBitCount);

	return res;
}

static TEEC_Result Invoke_BigIntInitFMMContext(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t context, uint32_t modSize, uint32_t mod)
{
	TEEC_Result res = TEE_ERROR_NOT_SUPPORTED;
	uint32_t org;
	(void)c;

	res = __invoke_command_2_value_input(sess, cmdId, &context, &mod, &modSize,
		&FIELD_NOT_USED, &org);

	return res;
}

static TEEC_Result Invoke_BigIntInvMod(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t dest, uint32_t op, uint32_t mod)
{
	TEEC_Result res = TEE_ERROR_NOT_SUPPORTED;
	BIGNUM *pBigIntDest;
	BIGNUM *pBigIntOp;
	BIGNUM *pBigIntMod;
	uint32_t org;
	(void)c;

	BN_DECLARE_AND_INIT(bn_inv_mod_exit);
	res = __invoke_command_2_value_input(sess, cmdId, &dest, &mod, &op, &FIELD_NOT_USED, &org);
	if (res != TEE_SUCCESS)
		goto bn_inv_mod_exit;

	pBigIntDest = (BIGNUM *)getBigIntFromId(p_ca_data, dest);
	if (pBigIntDest == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_inv_mod_exit;
	}
	pBigIntOp = (BIGNUM *)getBigIntFromId(p_ca_data, op);
	if (pBigIntOp == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_inv_mod_err;
	}
	pBigIntMod = (BIGNUM *)getBigIntFromId(p_ca_data, mod);
	if (pBigIntMod == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_inv_mod_err;
	}

	BN_mod_inverse(pBigIntDest, pBigIntOp, pBigIntMod, ctx);
	goto bn_inv_mod_exit;

bn_inv_mod_err:
	BN_clear_free(pBigIntDest);
bn_inv_mod_exit:
	BN_FREE();
	return res;
}

static TEEC_Result Invoke_BigIntMod(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t dest, uint32_t op, uint32_t mod)
{
	TEEC_Result res = TEE_ERROR_NOT_SUPPORTED;
	BIGNUM *pBigIntDest;
	BIGNUM *pBigIntOp;
	BIGNUM *pBigIntMod;
	uint32_t org;
	(void)c;

	BN_DECLARE_AND_INIT(bn_mod_exit);
	res = __invoke_command_2_value_input(sess, cmdId, &dest, &mod, &op,
		&FIELD_NOT_USED, &org);
	if (res != TEE_SUCCESS)
		goto bn_mod_exit;

	pBigIntDest = (BIGNUM *)getBigIntFromId(p_ca_data, dest);
	if (pBigIntDest == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_mod_exit;
	}
	pBigIntOp = (BIGNUM *)getBigIntFromId(p_ca_data, op);
	if (pBigIntOp == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_mod_err;
	}
	pBigIntMod = (BIGNUM *)getBigIntFromId(p_ca_data, mod);
	if (pBigIntMod == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_mod_err;
	}

	if (BN_mod(pBigIntDest, pBigIntOp, pBigIntMod, ctx))
		goto bn_mod_exit;

bn_mod_err:
	BN_clear_free(pBigIntDest);
bn_mod_exit:
	BN_FREE();
	return res;
}

static TEEC_Result Invoke_BigIntMul(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t dest, uint32_t op1, uint32_t op2)
{
	TEEC_Result res = TEE_ERROR_NOT_SUPPORTED;
	BIGNUM *pBigIntDest;
	BIGNUM *pBigIntOp1;
	BIGNUM *pBigIntOp2;
	uint32_t org;
	(void)c;

	BN_DECLARE_AND_INIT(bn_mul_exit);
	res = __invoke_command_2_value_input(sess, cmdId, &dest, &FIELD_NOT_USED, &op1, &op2, &org);
	if (res != TEE_SUCCESS)
		goto bn_mul_exit;

	pBigIntDest = (BIGNUM *)getBigIntFromId(p_ca_data, dest);
	if (pBigIntDest == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_mul_exit;
	}
	pBigIntOp1 = (BIGNUM *)getBigIntFromId(p_ca_data, op1);
	if (pBigIntOp1 == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_mul_err;
	}
	pBigIntOp2 = (BIGNUM *)getBigIntFromId(p_ca_data, op2);
	if (pBigIntOp2 == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_mul_err;
	}

	if (BN_mul(pBigIntDest, pBigIntOp1, pBigIntOp2, ctx))
		goto bn_mul_exit;

bn_mul_err:
	BN_clear_free(pBigIntDest);
bn_mul_exit:
	BN_FREE();
	return res;
}

static TEEC_Result Invoke_BigIntMulMod(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t dest, uint32_t op1, uint32_t op2, uint32_t mod)
{
	TEEC_Result res = TEE_ERROR_NOT_SUPPORTED;
	BIGNUM *pBigIntDest;
	BIGNUM *pBigIntOp1;
	BIGNUM *pBigIntOp2;
	BIGNUM *pBigIntMod;
	uint32_t org;
	(void)c;

	BN_DECLARE_AND_INIT(bn_mul_mod_exit);
	res = __invoke_command_2_value_input(sess, cmdId, &dest, &mod, &op1, &op2, &org);
	if (res != TEE_SUCCESS)
		goto bn_mul_mod_exit;

	pBigIntDest = (BIGNUM *)getBigIntFromId(p_ca_data, dest);
	if (pBigIntDest == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_mul_mod_exit;
	}
	pBigIntOp1 = (BIGNUM *)getBigIntFromId(p_ca_data, op1);
	if (pBigIntOp1 == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_mul_mod_err;
	}
	pBigIntOp2 = (BIGNUM *)getBigIntFromId(p_ca_data, op2);
	if (pBigIntOp2 == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_mul_mod_err;
	}
	pBigIntMod = (BIGNUM *)getBigIntFromId(p_ca_data, mod);
	if (pBigIntMod == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_mul_mod_err;
	}

	if (BN_mod_mul(pBigIntDest, pBigIntOp1, pBigIntOp2, pBigIntMod, ctx))
		goto bn_mul_mod_exit;

bn_mul_mod_err:
	BN_clear_free(pBigIntDest);
bn_mul_mod_exit:
	BN_FREE();
	return res;
}

static TEEC_Result Invoke_BigIntNeg(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t dest, uint32_t op)
{
	TEEC_Result res = TEE_ERROR_NOT_SUPPORTED;
	BIGNUM *pBigIntDest;
	BIGNUM *pBigIntOp;
	BIGNUM *bigNumZero = BN_new();
	uint32_t org;
	(void)c;

	res = __invoke_command_2_value_input(sess, cmdId, &dest, &FIELD_NOT_USED, &op, &FIELD_NOT_USED, &org);
	if (res != TEE_SUCCESS)
		goto bn_neg_exit;

	if (!BN_dec2bn(&bigNumZero, "0"))
		goto bn_neg_exit;

	pBigIntDest = (BIGNUM *)getBigIntFromId(p_ca_data, dest);
	if (pBigIntDest == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_neg_exit;
	}

	pBigIntOp = (BIGNUM *)getBigIntFromId(p_ca_data, op);
	if (pBigIntOp == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_neg_err;
	}

	if (BN_sub(pBigIntDest, bigNumZero, pBigIntOp))
		goto bn_neg_exit;

bn_neg_err:
	BN_clear_free(pBigIntDest);
bn_neg_exit:
	BN_free(bigNumZero);
	return res;
}

static TEEC_Result Invoke_BigIntShiftRight(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t dest, uint32_t op, uint32_t bits)
{
	TEEC_Result res = TEE_ERROR_NOT_SUPPORTED;
	BIGNUM *pBigIntDest;
	BIGNUM *pBigIntOp;
	uint32_t org;
	(void)c;

	res = __invoke_command_2_value_input(sess, cmdId, &dest, &op, &bits, &FIELD_NOT_USED, &org);
	if (res != TEE_SUCCESS)
		goto bn_shift_right_exit;

	pBigIntDest = (BIGNUM *)getBigIntFromId(p_ca_data, dest);
	if (pBigIntDest == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_shift_right_exit;
	}
	pBigIntOp = (BIGNUM *)getBigIntFromId(p_ca_data, op);
	if (pBigIntOp == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_shift_right_err;
	}
	if (BN_rshift(pBigIntDest, pBigIntOp, bits))
		goto bn_shift_right_exit;

bn_shift_right_err:
	BN_clear_free(pBigIntDest);
bn_shift_right_exit:
	return res;
}

static TEEC_Result Invoke_BigIntSquare(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t dest, uint32_t op)
{
	TEEC_Result res = TEE_ERROR_NOT_SUPPORTED;
	BIGNUM *pBigIntDest;
	BIGNUM *pBigIntOp;
	uint32_t org;
	(void)c;

	BN_DECLARE_AND_INIT(bn_sqr_exit);
	res = __invoke_command_2_value_input(sess, cmdId, &dest, &FIELD_NOT_USED, &op, &FIELD_NOT_USED, &org);
	if (res != TEE_SUCCESS)
		goto bn_sqr_exit;

	pBigIntDest = (BIGNUM *)getBigIntFromId(p_ca_data, dest);
	if (pBigIntDest == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_sqr_exit;
	}
	pBigIntOp = (BIGNUM *)getBigIntFromId(p_ca_data, op);
	if (pBigIntOp == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_sqr_err;
	}
	if (BN_sqr(pBigIntDest, pBigIntOp, ctx))
		goto bn_sqr_exit;

bn_sqr_err:
	BN_clear_free(pBigIntDest);
bn_sqr_exit:
	BN_FREE();
	return res;
}

static TEEC_Result Invoke_BigIntSquareMod(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t dest, uint32_t op, uint32_t mod)
{
	TEEC_Result res = TEE_ERROR_NOT_SUPPORTED;
	BIGNUM *pBigIntDest;
	BIGNUM *pBigIntOp;
	BIGNUM *pBigIntMod;
	uint32_t org;
	(void)c;

	BN_DECLARE_AND_INIT(bn_mod_sqr_exit);
	res = __invoke_command_2_value_input(sess, cmdId, &dest, &mod, &op, &FIELD_NOT_USED, &org);
	if (res != TEE_SUCCESS)
		goto bn_mod_sqr_exit;

	pBigIntDest = (BIGNUM *)getBigIntFromId(p_ca_data, dest);
	if (pBigIntDest == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_mod_sqr_exit;
	}
	pBigIntOp = (BIGNUM *)getBigIntFromId(p_ca_data, op);
	if (pBigIntOp == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_mod_sqr_err;
	}
	pBigIntMod = (BIGNUM *)getBigIntFromId(p_ca_data, mod);
	if (pBigIntMod == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_mod_sqr_err;
	}
	if (BN_mod_sqr(pBigIntDest, pBigIntOp, pBigIntMod, ctx))
		goto bn_mod_sqr_exit;

bn_mod_sqr_err:
	BN_clear_free(pBigIntDest);
bn_mod_sqr_exit:
	BN_FREE();
	return res;
}

static TEEC_Result Invoke_BigIntSub(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t dest, uint32_t op1, uint32_t op2)
{
	TEEC_Result res = TEE_ERROR_NOT_SUPPORTED;
	BIGNUM *pBigIntDest;
	BIGNUM *pBigIntOp1;
	BIGNUM *pBigIntOp2;
	uint32_t org;
	(void)c;

	res = __invoke_command_2_value_input(sess, cmdId, &dest, &FIELD_NOT_USED, &op1, &op2, &org);
	if (res != TEE_SUCCESS)
		goto bn_sub_exit;

	pBigIntDest = (BIGNUM *)getBigIntFromId(p_ca_data, dest);
	if (pBigIntDest == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_sub_exit;
	}
	pBigIntOp1 = (BIGNUM *)getBigIntFromId(p_ca_data, op1);
	if (pBigIntOp1 == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_sub_err;
	}
	pBigIntOp2 = (BIGNUM *)getBigIntFromId(p_ca_data, op2);
	if (pBigIntOp2 == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_sub_err;
	}
	if (BN_sub(pBigIntDest, pBigIntOp1, pBigIntOp2))
		goto bn_sub_exit;

bn_sub_err:
	BN_clear_free(pBigIntDest);
bn_sub_exit:
	return res;
}

static TEEC_Result Invoke_BigIntSubMod(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t dest, uint32_t op1, uint32_t op2, uint32_t mod)
{
	TEEC_Result res = TEE_ERROR_NOT_SUPPORTED;
	BIGNUM *pBigIntDest;
	BIGNUM *pBigIntOp1;
	BIGNUM *pBigIntOp2;
	BIGNUM *pBigIntMod;
	uint32_t org;
	(void)c;

	BN_DECLARE_AND_INIT(bn_mod_sub_exit);
	res = __invoke_command_2_value_input(sess, cmdId, &dest, &mod, &op1, &op2, &org);
	if (res != TEE_SUCCESS)
		goto bn_mod_sub_exit;

	pBigIntDest = (BIGNUM *)getBigIntFromId(p_ca_data, dest);
	if (pBigIntDest == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_mod_sub_exit;
	}
	pBigIntOp1 = (BIGNUM *)getBigIntFromId(p_ca_data, op1);
	if (pBigIntOp1 == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_mod_sub_err;
	}
	pBigIntOp2 = (BIGNUM *)getBigIntFromId(p_ca_data, op2);
	if (pBigIntOp2 == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_mod_sub_err;
	}
	pBigIntMod = (BIGNUM *)getBigIntFromId(p_ca_data, mod);
	if (pBigIntMod == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_mod_sub_err;
	}
	if (BN_mod_sub(pBigIntDest, pBigIntOp1, pBigIntOp2, pBigIntMod, ctx))
		goto bn_mod_sub_exit;

bn_mod_sub_err:
	BN_clear_free(pBigIntDest);
bn_mod_sub_exit:
	BN_FREE();
	return res;
}

static TEEC_Result Invoke_StoreS32(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t role, uint32_t positive, uint8_t *value)
{
	TEEC_Result res = TEE_ERROR_NOT_SUPPORTED;
	int32_t shortVal;
	uint32_t org;
	uint32_t valueS32 = 0;
	uint8_t *pVal = value;
	int n = sizeof(uint32_t);
	(void)c;

	/* Copy value into big-endian form. */
	while (n--) {
		valueS32 = (valueS32 << 8L) | *(pVal++);
	}

	res = __invoke_command_2_value_input(sess, cmdId, &role, &positive, &valueS32, &FIELD_NOT_USED, &org);
	if (res != TEE_SUCCESS)
		goto bn_store_s32_exit;

	if (!positive)
	{
		if (valueS32 > (1 + (uint32_t)MAX_INT32_POSITIVE_VALUE))
			return TEEC_ERROR_BAD_PARAMETERS;

		shortVal = -valueS32;
	}
	else
	{
		if (valueS32 > MAX_INT32_POSITIVE_VALUE)
			return TEEC_ERROR_BAD_PARAMETERS;

		shortVal = valueS32;
	}

	switch (role)
	{

	case SHORT_VAL_1:
		p_ca_data->nShortVal = shortVal;
		p_ca_data->bShortValSet = true;
		break;

	default:
		return TEEC_ERROR_BAD_PARAMETERS;
	}

	return TEE_SUCCESS;

bn_store_s32_exit:
	return res;
}

static TEEC_Result Invoke_Wait(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId, uint32_t Case)
{
	TEEC_Result res = TEE_ERROR_NOT_SUPPORTED;
	TEEC_Operation op = TEEC_OPERATION_INITIALIZER;
	uint32_t org;
	(void)c;

	op.params[0].value.a = Case;

	op.paramTypes = TEEC_PARAM_TYPES(
		TEEC_VALUE_INPUT, TEEC_NONE, TEEC_NONE, TEEC_NONE);

	res = TEEC_InvokeCommand(sess, cmdId, &op, &org);

	return res;
}

static TEEC_Result Invoke_NewBigInt(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t role, uint32_t size_N)
{
	TEEC_Result res = TEE_ERROR_NOT_SUPPORTED;
	uint32_t org;
	BIGNUM *pNewBigInt;
	BIGNUM **ppBigInt;
	(void)c;

	res = __invoke_command_1_value_input(sess, cmdId, &role, &size_N, &org);

	if (res == TEE_SUCCESS) {
		/* Allocate and initialize BIGNUM structure for BigInt handling on CA
		 * side.
		 */
		ppBigInt = (BIGNUM **)getBigIntPtrFromId(p_ca_data, role);
		if (ppBigInt == NULL)
			return TEE_ERROR_NOT_SUPPORTED;
		pNewBigInt = BN_new();
		if (pNewBigInt == NULL)
			return TEE_ERROR_OUT_OF_MEMORY;
		*ppBigInt = pNewBigInt;
	}

	return res;
}

static TEEC_Result Invoke_NewBigIntFMM(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t role, uint32_t size_N)
{
	TEEC_Result res = TEE_ERROR_NOT_SUPPORTED;
	uint32_t org;
	BIGNUM *pNewBigInt;
	BIGNUM **ppBigInt;
	(void)c;

	res = __invoke_command_1_value_input(sess, cmdId, &role, &size_N, &org);

	if (res == TEE_SUCCESS) {
		/* Allocate and initialize BIGNUM structure for BigInt handling on CA
		 * side.
		 */
		ppBigInt = (BIGNUM **)getBigIntFMMPtrFromId(p_ca_data, role);
		if (ppBigInt == NULL)
			return TEE_ERROR_NOT_SUPPORTED;
		pNewBigInt = BN_new();
		if (pNewBigInt == NULL)
			return TEE_ERROR_OUT_OF_MEMORY;
		*ppBigInt = pNewBigInt;
	}

	return res;
}

static TEEC_Result Invoke_BigIntConvertFromOctetString(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t dest, uint32_t size_N, uint32_t sign, uint8_t *value)
{
	TEEC_Result res = TEE_ERROR_NOT_SUPPORTED;
	TEEC_Operation op = TEEC_OPERATION_INITIALIZER;
	uint32_t org;
	uint32_t tmp = 0;
	(void)c;
	BIGNUM *pBigInt = NULL;

	ALLOCATE_AND_FILL_SHARED_MEMORY_6(sess->ctx, SHARE_MEM01,
					((size_N + 7) / 8),
					TEEC_MEM_INPUT, value, mem01_exit);

	op.params[0].value.a = dest;

	if (sign == 0)
		tmp = tmp | BIT0_MASK;

	op.params[1].value.a = sign;

	SET_SHARED_MEMORY_OPERATION_PARAMETER(2, 0, SHARE_MEM01,
					      SHARE_MEM01->size);

	op.paramTypes = TEEC_PARAM_TYPES(
		TEEC_VALUE_INPUT, TEEC_VALUE_INPUT, TEEC_MEMREF_PARTIAL_INPUT,
		TEEC_NONE);

	res = TEEC_InvokeCommand(sess, cmdId, &op, &org);

	if (res == TEE_SUCCESS) {
		/* Allocate and initialize BIGNUM structure for BigInt handling on CA side */
		pBigInt = (BIGNUM *)getBigIntFromId(p_ca_data, dest);
		if (pBigInt == NULL) {
			res = TEE_ERROR_NOT_SUPPORTED;
			goto ca_bn_err;
		}
		if (!BN_bin2bn(SHARE_MEM01->buffer, SHARE_MEM01->size, pBigInt))
			goto ca_bn_err;
		BN_set_negative(pBigInt, tmp);
	}

ca_bn_err:
	TEEC_ReleaseSharedMemory(SHARE_MEM01);
mem01_exit:
	return res;
}

static TEEC_Result Invoke_BigIntConvertToOctetString(
	ADBG_Case_t *c, TEEC_Session *sess, uint32_t cmdId,
	uint32_t bigInt, uint32_t size)
{
	TEEC_Result res = TEE_ERROR_NOT_SUPPORTED;
	TEEC_Operation op = TEEC_OPERATION_INITIALIZER;
	uint32_t org;
	(void)c;
	BIGNUM *pBigInt = NULL;
	BIGNUM *pBigIntRet = BN_new();
	int sign = 0;

	ALLOCATE_SHARED_MEMORY(sess->ctx, SHARE_MEM01,
					((size + 7) / 8),
					TEEC_MEM_OUTPUT, mem01_exit);

	op.params[0].value.a = bigInt;

	SET_SHARED_MEMORY_OPERATION_PARAMETER(2, 0, SHARE_MEM01,
					      SHARE_MEM01->size);

	op.paramTypes = TEEC_PARAM_TYPES(
		TEEC_VALUE_INPUT, TEEC_VALUE_OUTPUT, TEEC_MEMREF_PARTIAL_OUTPUT,
		TEEC_NONE);

	res = TEEC_InvokeCommand(sess, cmdId, &op, &org);

	if (res != TEE_SUCCESS)
		goto bn_to_octet_err;

	/* Allocate and initialize BIGNUM structure for BigInt handling on CA side */
	pBigInt = (BIGNUM *)getBigIntFromId(p_ca_data, bigInt);
	if (pBigInt == NULL) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto bn_to_octet_err;
	}
	if (!BN_bin2bn(SHARE_MEM01->buffer, op.params[2].memref.size, pBigIntRet))
		goto bn_to_octet_err;
	if (op.params[1].value.a == 0)
		sign = 1;
	BN_set_negative(pBigIntRet,sign);

	(void)ADBG_EXPECT_COMPARE_SIGNED(c,
					 0, ==,
					 BN_cmp(pBigInt, pBigIntRet));

bn_to_octet_err:
	TEEC_ReleaseSharedMemory(SHARE_MEM01);
mem01_exit:
	BN_free(pBigIntRet);
	return res;
}

#endif /* XML_TIMEARITHM_API_H_ */
